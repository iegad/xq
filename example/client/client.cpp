#define KC_EVENT_ON_SEND 0
#define KC_EVENT_ON_RECV 0

#include "xq/tools/tools.hpp"
#include "xq/net/kcp_conn.hpp"
#include <spdlog/spdlog.h>
#include <spdlog/sinks/rotating_file_sink.h>
#include <csignal>

#ifndef WIN32
#include <jemalloc/jemalloc.h>
#endif

class EchoEvent;

const std::string host = "1.15.81.179:6688";
constexpr int NTIMES = 200000;

static std::atomic<int> ncount(0);
static xq::net::KcpConn<EchoEvent>::Ptr conn;
static int64_t beg = 0;

class EchoEvent {
public:
	typedef xq::net::KcpConn<EchoEvent> KcpConn;
	typedef KcpConn::Host KcpHost;

	int on_message(KcpHost* host, const uint8_t* data, size_t datalen) {
		std::string tmp((const char*)data, datalen);
		rl_->info(tmp);
		std::printf("%s\n", tmp.c_str());
		ncount++;
		if (ncount == NTIMES) {
			std::printf("%d packages, takes: %ld milliseconds\n", NTIMES, xq::tools::now_milli() - beg);
			conn->stop();
		}
		return 0;
	}

	void on_error(xq::net::ErrType err_type, int err, void* arg) {

	}


	int on_recv(const uint8_t* raw, size_t rawlen, const sockaddr*, socklen_t) {
		xq::net::Kcp::Segment* seg = xq::net::Kcp::Segment::pool()->get();
		const uint8_t* p = raw;

		while (rawlen > 0) {
			int n = xq::net::Kcp::decode(p, rawlen, seg);
			raw += n;
			rawlen -= n;
			rl_->info("RCV-> " + seg->to_string());
		}

		xq::net::Kcp::Segment::pool()->put(seg);
		return 0;
	}


	void on_send(const uint8_t* raw, size_t rawlen, const sockaddr*, socklen_t) {
		xq::net::Kcp::Segment* seg = xq::net::Kcp::Segment::pool()->get();
		const uint8_t* p = raw;

		while (rawlen > 0) {
			int n = xq::net::Kcp::decode(p, rawlen, seg);
			raw += n;
			rawlen -= n;
			tl_->info("SND-> " + seg->to_string());
		}

		xq::net::Kcp::Segment::pool()->put(seg);
	}

	EchoEvent() 
		: rl_(spdlog::rotating_logger_st("recv", SPDLOG_FILENAME_T("recv.txt"), 1024 * 1024 * 1024, 0))
		, tl_(spdlog::rotating_logger_st("send", SPDLOG_FILENAME_T("send.txt"), 1024 * 1024 * 1024, 0))
	{}

	~EchoEvent() {
		rl_->flush();
	}

private:
	std::shared_ptr<spdlog::logger> rl_;
	std::shared_ptr<spdlog::logger> tl_;
};



void worker() {
	std::this_thread::sleep_for(std::chrono::seconds(1));

	char* buf = new char[xq::net::KCP_MAX_DATA_SIZE];
	::memset(buf, 0, xq::net::KCP_MAX_DATA_SIZE);

	beg = xq::tools::now_milli();
	for (int i = 0; i < NTIMES;) {
		sprintf(buf, "---- %d ---- 1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890", i);
		
		int n = conn->send(host, (uint8_t *)buf, strlen(buf));
		if (n < 0) {
			std::printf("conn->send failed: %d\n", n);
			exit(1);
		}
		else if (n == 1) {
			std::this_thread::sleep_for(std::chrono::milliseconds(xq::net::KCP_UPDATE_MS));
		}
		else {
			i++;
		}
		std::this_thread::yield();
	}

	delete[] buf;
}

#include "xq/third/AES.h"

void signal_handler(int signal) {
	if (signal == SIGINT && conn) {
		conn->stop();
	}
}

int
main(int argc, char** argv) {
	if (argc < 2) {
		std::printf("ÇëÊäÈëconv\b");
		exit(EXIT_FAILURE);
	}

	uint32_t conv = std::stoi(argv[1]);

#ifdef _WIN32
	WSADATA wdata;
	if (WSAStartup(0x0202, &wdata) || wdata.wHighVersion != 0x0202)
		exit(EXIT_FAILURE);
#endif // _WIN32
	std::vector<std::string> hosts{host};
	conn = EchoEvent::KcpConn::create(conv, ":0", hosts);

	std::signal(SIGINT, signal_handler);

	std::thread(worker).detach();
	conn->run();
	std::printf(">>> DONE...!!!\n");
#ifdef _WIN32
	WSACleanup();
#endif // _WIN32
	exit(EXIT_SUCCESS);
}